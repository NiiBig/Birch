/**
 * Singly-linked tape. Maintains a current position along the tape, and
 * provides $O(1)$ operations at that position, but in the worst case an
 * $O(N)$ seek is required before operations at any other position. Beyond its
 * typical uses, because Tape is a recursive and single-linked data
 * structure, it provides excellent sharing under Birch's lazy deep copy
 * mechanism.
 *
 * An [Iterator](../Iterator) may be obtained over a Tape by calling `walk()`,
 * as per the usual idiom. In addition, a Tape is itself an iterator: its
 * own `hasNext()` and `next()` functions implement the required semantics for
 * Iterator. Tape inherits from Iterator for this reason.
 *
 * !!! attention
 *     See note under List for possible stack overflow issues on the
 *     destruction of large Tape objects. 
 */
final class Tape<Type> < Iterator<Type> {
  forward:TapeNode<Type>?;
  backward:TapeNode<Type>?;
  forwardCount:Integer <- 0;
  backwardCount:Integer <- 0;

  /**
   * Number of elements.
   */
  function size() -> Integer {
    return forwardCount + backwardCount;
  }

  /**
   * Is this empty?
   */
  function empty() -> Boolean {
    return forwardCount + backwardCount == 0;
  }

  /**
   * Clear all elements.
   */
  function clear() {
    forward <- nil;
    backward <- nil;
    forwardCount <- 0;
    backwardCount <- 0;
  }

  /**
   * Rewind to the first element and return it.
   */
  function front() -> Type {
    rewind();
    return here();
  }

  /**
   * Fast-forward to one past the last element and return the last element.
   */
  function back() -> Type {
    fastForward();
    return before();
  }

  /**
   * Rewind to the first element.
   */
  function rewind() {
    while hasPrevious() {
      previous();
    }
  }

  /**
   * Fast-forward to one past the last element.
   */
  function fastForward() {
    while hasNext() {
      next();
    }
  }

  /**
   * Is there an element at the current position?
   *
   * !!! tip
   *     This is equivalent to `hasHere()`.
   */
  function hasNext() -> Boolean {
    return forward?;
  }

  /**
   * Is there an element before the current position?
   *
   * !!! tip
   *     This is equivalent to `hasBefore()`.
   */
  function hasPrevious() -> Boolean {
    return backward?;
  }

  /**
   * Is there an element at the current position?
   *
   * !!! tip
   *     This is equivalent to `hasNext()`.
   */
  function hasHere() -> Boolean {
    return forward?;
  }

  /**
   * Is there an element before the current position?
   *
   * !!! tip
   *     This is equivalent to `hasPrevious()`.
   */
  function hasBefore() -> Boolean {
    return backward?;
  }

  /**
   * Move the head forward one, and return the element at the previous
   * position.
   *
   * !!! tip
   *     This returns the same element as `here()`, but also moves the head.
   */
  function next() -> Type {
    auto node <- forward!;
    forward <- node.next;
    node.next <- backward;
    backward <- node;
    forwardCount <- forwardCount - 1;
    backwardCount <- backwardCount + 1;
    return before();
  }

  /**
   * Move the head backward one, and return the element at the new position.
   *
   * !!! tip
   *     This returns the same element as `before()`, but also moves the head.
   */
  function previous() -> Type {
    auto node <- backward!;
    backward <- node.next;
    node.next <- forward;
    forward <- node;
    forwardCount <- forwardCount + 1;
    backwardCount <- backwardCount - 1;
    return here();
  }

  /**
   * Get the element at the current position.
   *
   * !!! tip
   *     This returns the same element as `next()`, but does not move the
   *     head.
   */
  function here() -> Type {
    assert forward?;
    return forward!.x;
  }

  /**
   * Get the element before the current position.
   *
   * !!! tip
   *     This returns the same element as `previous()`, but does not move the
   *     head.
   */
  function before() -> Type {
    assert backward?;
    return backward!.x;
  }

  /**
   * Insert an element at the front.
   *
   * - x: Value.
   */
  function pushFront(x:Type) {
    rewind();
    pushHere(x);
  }

  /**
   * Insert a new default-constructed element at the front and return it.
   */
  function pushFront() -> Type {
    auto x <- make<Type>();
    if x? {
      pushFront(x!);
    } else {
      error("not default constructible");
    }
    return x!;
  }

  /**
   * Insert an element at the back.
   *
   * - x: Value.
   */
  function pushBack(x:Type) {
    fastForward();
    pushBefore(x);
  }

  /**
   * Insert a new default-constructed element at the back and return it.
   */
  function pushBack() -> Type {
    auto x <- make<Type>();
    if x? {
      pushBack(x!);
    } else {
      error("not default constructible");
    }
    return x!;
  }

  /**
   * Remove the first element and return it.
   */
  function popFront() -> Type {
    rewind();
    return popHere();
  }

  /**
   * Remove the last element and return it.
   */
  function popBack() -> Type {
    fastForward();
    return popBefore();
  }

  /**
   * Insert an element at the current position.
   *
   * - x: Value.
   */
  function pushHere(x:Type) {
    node:TapeNode<Type>(x);
    node.next <- forward;
    forward <- node;
    forwardCount <- forwardCount + 1;
  }

  /**
   * Insert a new default-constructed element at the current position and
   * return it.
   */
  function pushHere() -> Type {
    auto x <- make<Type>();
    if x? {
      pushHere(x!);
    } else {
      error("not default constructible");
    }
    return x!;
  }

  /**
   * Insert an element before the current position.
   *
   * - x: Value.
   */
  function pushBefore(x:Type) {
    node:TapeNode<Type>(x);
    node.next <- backward;
    backward <- node;
    backwardCount <- backwardCount + 1;
  }

  /**
   * Insert a new default-constructed element before the current position and
   * return it.
   */
  function pushBefore() -> Type {
    auto x <- make<Type>();
    if x? {
      pushBefore(x!);
    } else {
      error("not default constructible");
    }
    return x!;
  }

  /**
   * Remove the element at the current position and return it.
   */
  function popHere() -> Type {
    auto node <- forward!;
    forward <- forward!.next;
    forwardCount <- forwardCount - 1;
    return node.x;
  }

  /**
   * Remove the element before the current position and return it.
   */
  function popBefore() -> Type {
    auto node <- backward!;
    backward <- backward!.next;
    backwardCount <- backwardCount - 1;
    return node.x;
  }
  
  /**
   * Obtain an iterator.
   *
   * Return: an iterator across elements in forward order.
   */
  function walk() -> Iterator<Type> {
    rewind();
    return TapeIterator<Type>(forward);
  }

  function read(buffer:Buffer) {
    auto f <- buffer.walk();
    while f.hasNext() {
      /* tricky, but works for both value and class types */
      auto x <- make<Type>();
      auto y <- f.next().get(x);
      if y? {
        x <- Type?(y);  // cast needed for y:Object?
        pushBack(x!);
      }
    }
    rewind();
  }

  function write(buffer:Buffer) {
    buffer.setArray();
    auto f <- walk();
    while f.hasNext() {
      buffer.push().set(f.next());
    }
  }
}
