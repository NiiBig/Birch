/**
 * @file
 *
 * Standard headers that should be included for all C++ files generated by
 * the compiler.
 */
#pragma once

#include "libbirch/external.hpp"
#include "libbirch/assert.hpp"
#include "libbirch/memory.hpp"
#include "libbirch/stacktrace.hpp"
#include "libbirch/class.hpp"
#include "libbirch/basic.hpp"
#include "libbirch/type.hpp"
#include "libbirch/thread.hpp"

#include "libbirch/Span.hpp"
#include "libbirch/Index.hpp"
#include "libbirch/Range.hpp"
#include "libbirch/Frame.hpp"
#include "libbirch/View.hpp"
#include "libbirch/Array.hpp"
#include "libbirch/Tuple.hpp"
#include "libbirch/Tie.hpp"
#include "libbirch/Any.hpp"
#include "libbirch/Optional.hpp"
#include "libbirch/Nil.hpp"
#include "libbirch/Init.hpp"
#include "libbirch/Shared.hpp"
#include "libbirch/Weak.hpp"
#include "libbirch/FiberState.hpp"
#include "libbirch/Fiber.hpp"
#include "libbirch/Eigen.hpp"
#include "libbirch/EigenFunctions.hpp"
#include "libbirch/EigenOperators.hpp"

/**
 * LibBirch.
 */
namespace libbirch {
/**
 * Default array for `D` dimensions.
 */
template<class T, int D>
using DefaultArray = Array<T,typename DefaultFrame<D>::type>;

/**
 * Default view for `D`-dimensional indexing of a single element.
 */
template<int D>
struct DefaultView {
  typedef NonemptyView<Index<>,typename DefaultView<D - 1>::type> type;
};
template<>
struct DefaultView<0> {
  typedef EmptyView type;
};

/**
 * Make a range.
 *
 * @ingroup libbirch
 *
 * @param start First index.
 * @param end Last index.
 */
inline Range<> make_range(const int64_t start, const int64_t end) {
  int64_t length = std::max(int64_t(0), end - start + 1);
  return Range<>(start, length);
}

/**
 * Make a frame, no arguments.
 *
 * @ingroup libbirch
 */
inline EmptyFrame make_frame() {
  return EmptyFrame();
}

/**
 * Make a frame, single argument.
 *
 * @ingroup libbirch
 */
inline NonemptyFrame<Span<>,EmptyFrame> make_frame(const int64_t arg) {
  auto tail = EmptyFrame();
  auto head = Span<>(arg, tail.volume());
  return NonemptyFrame<Span<>,EmptyFrame>(head, tail);
}

/**
 * Make a frame, multiple arguments.
 *
 * @ingroup libbirch
 */
template<class ... Args>
auto make_frame(const int64_t arg, Args ... args) {
  auto tail = make_frame(args...);
  auto head = Span<>(arg, tail.volume());
  return NonemptyFrame<decltype(head),decltype(tail)>(head, tail);
}

/**
 * Make a frame, recursively.
 *
 * @ingroup libbirch
 */
template<class ... Args>
auto make_frame(const int64_t arg, const NonemptyFrame<Args...>& tail) {
  auto head = Span<>(arg, tail.volume());
  return NonemptyFrame<decltype(head),decltype(tail)>(head, tail);
}

/**
 * Make a view, no arguments.
 *
 * @ingroup libbirch
 */
inline EmptyView make_view() {
  return EmptyView();
}

/**
 * Make a view, single argument.
 *
 * @ingroup libbirch
 */
template<int64_t offset_value, int64_t length_value>
auto make_view(const Range<offset_value,length_value>& arg) {
  auto head = arg;
  auto tail = make_view();
  return NonemptyView<decltype(head),decltype(tail)>(head, tail);
}

/**
 * Make a view, single argument.
 *
 * @ingroup libbirch
 */
inline NonemptyView<Index<>,EmptyView> make_view(const int64_t arg) {
  auto head = Index<>(arg);
  auto tail = EmptyView();
  return NonemptyView<Index<>,EmptyView>(head, tail);
}

/**
 * Make a view, multiple arguments.
 *
 * @ingroup libbirch
 */
template<int64_t offset_value, int64_t length_value, class ... Args>
auto make_view(const Range<offset_value,length_value>& arg, Args ... args) {
  auto head = arg;
  auto tail = make_view(args...);
  return NonemptyView<decltype(head),decltype(tail)>(head, tail);
}

/**
 * Make a view, multiple arguments.
 *
 * @ingroup libbirch
 */
template<class ... Args>
auto make_view(const int64_t arg, Args ... args) {
  auto head = Index<mutable_value>(arg);
  auto tail = make_view(args...);
  return NonemptyView<decltype(head),decltype(tail)>(head, tail);
}

/**
 * Make an array of value type.
 *
 * @ingroup libbirch
 *
 * @tparam Type Value type.
 * @tparam Frame Frame type.
 * @tparam Args Constructor parameter types.
 *
 * @param frame Frame.
 * @param args Constructor arguments.
 *
 * @return The array.
 */
template<class Type, class Frame, class ... Args>
Array<Type,Frame> make_array(const Frame& frame, const Args&... args) {
  return Array<Type,Frame>(frame, args...);
}

/**
 * Make an array of non-value type.
 *
 * @ingroup libbirch
 *
 * @tparam Type Value type.
 * @tparam Frame Frame type.
 * @tparam Args Constructor parameter types.
 *
 * @param context Current context.
 * @param frame Frame.
 * @param args Constructor arguments.
 *
 * @return The array.
 */
template<class Type, class Frame, class ... Args>
Array<Type,Frame> make_array(Label* context, const Frame& frame,
    const Args&... args) {
  return Array<Type,Frame>(context, frame, args...);
}

/**
 * Make an array and assign a value to it.
 *
 * @ingroup libbirch
 *
 * @tparam Type Value type.
 * @tparam Frame Frame type.
 * @tparam Value Initial value type.
 *
 * @param frame Frame.
 * @param value Initial value.
 *
 * @return The array.
 */
template<class Type, class Frame, class Value>
Array<Type,Frame> make_array_and_assign(const Frame& frame,
    const Value& value) {
  Array<Type,Frame> result;
  result.enlarge(frame, value);
  return result;
}

/**
 * Make an object.
 *
 * @ingroup libbirch
 *
 * @tparam Type Object type.
 * @tparam Args Constructor parameter types.
 *
 * @param context Current context.
 * @param args Constructor arguments.
 *
 * @return A raw pointer to the new object.
 */
template<class Type, class ... Args>
Type* make_object(Label* context, const Args& ... args) {
  return new Type(context, args...);
}

/**
 * Clone an object.
 *
 * @ingroup libbirch
 *
 * @tparam Type Object type.
 *
 * @param context Current context.
 * @param o The object.
 *
 * @return A raw pointer to the new object.
 *
 * @note Typically, one uses the clone_() virtual member function of an
 * object, which calls this function, rather than calling this function
 * directly, to ensure that Type is the most derived type of the object.
 */
template<class Type>
Type* clone_object(Label* context, const Type* o) {
  return make_object<Type>(context, context, *o);
}

/**
 * Make a pointer, with in-place object construction.
 *
 * @ingroup libbirch
 *
 * @tparam P Pointer type.
 * @tparam Args Constructor parameter types.
 *
 * @param context Current context.
 * @param args Constructor arguments.
 *
 * @return A pointer of the given type.
 */
template<class P, class ... Args>
P make_pointer(Label* context, const Args& ... args) {
  return P(context, make_object<typename P::value_type>(context, args...));
}

/**
 * Make a fiber.
 *
 * @tparam StateType The state type of the fiber.
 * @tparam Args Fiber state constructor parameter types.
 *
 * @param context Current context.
 * @param args Fiber state constructor arguments.
 */
template<class StateType, class ... Args>
Fiber<typename StateType::yield_type_> make_fiber(Label* context,
    const Args&... args) {
  return Fiber<typename StateType::yield_type_>(context,
      Shared<StateType>(context, make_object<StateType>(context, args...)));
}

/**
 * Make a tuple.
 *
 * @tparam Head First element type.
 * @tparam Tail Remaining element types.
 *
 * @param head First element.
 * @param tail Remaining elements.
 */
template<class Head, class... Tail>
Tuple<Head,Tail...> make_tuple(const Head& head, const Tail&... tail) {
  return Tuple<Head,Tail...>(head, tail...);
}

/**
 * Make a tuple.
 *
 * @tparam Head First element type.
 * @tparam Tail Remaining element types.
 *
 * @param head First element.
 * @param tail Remaining elements.
 */
template<class Head, class... Tail>
Tuple<Head,Tail...> make_tuple(Label* context, const Head& head,
    const Tail&... tail) {
  return Tuple<Head,Tail...>(context, head, tail...);
}

/**
 * Make an assignable tuple.
 *
 * @tparam Head First element type.
 * @tparam Tail Remaining element types.
 *
 * @param head First element.
 * @param tail Remaining elements.
 */
template<class Head, class... Tail>
Tie<Head&,Tail&...> tie(Head& head, Tail&... tail) {
  return Tie<Head&,Tail&...>(head, tail...);
}

/**
 * Make an assignable tuple.
 *
 * @tparam Head First element type.
 * @tparam Tail Remaining element types.
 *
 * @param head First element.
 * @param tail Remaining elements.
 */
template<class Head, class... Tail>
Tie<Head&,Tail&...> tie(Label* context, Head& head, Tail&... tail) {
  return Tie<Head&,Tail&...>(context, head, tail...);
}

/**
 * Make a value.
 *
 * @tparam Type Value type.
 *
 * @return An optional with a default-constructed value of the given type.
 */
template<class Type, IS_VALUE(Type)>
Optional<Type> make(Label* context) {
  return Optional<Type>(Type());
}

/**
 * Make an object.
 *
 * @tparam Type Pointer type.
 *
 * @return An optional with a value of the given type if that type is
 * default-constructible, otherwise no value.
 */
template<class Type, IS_POINTER(Type), IS_DEFAULT_CONSTRUCTIBLE(Type)>
Optional<Type> make(Label* context) {
  return Optional<Type>(make_pointer<Type>(context));
}

/**
 * Make an object.
 *
 * @tparam Type Pointer type.
 *
 * @return An optional with a value of the given type if that type is
 * default-constructible, otherwise no value.
 */
template<class Type, IS_POINTER(Type), IS_NOT_DEFAULT_CONSTRUCTIBLE(Type)>
Optional<Type> make(Label* context) {
  assert(false);
  return Optional<Type>();
}

/**
 * Cast an object.
 */
template<class To, class From>
Optional<To> dynamic_pointer_cast(Label* context, const Shared<From>& from) {
  return Optional<To>(context, from.template dynamic_pointer_cast<To>(context));
}

/**
 * Cast an object optional.
 */
template<class To, class From>
Optional<To> dynamic_pointer_cast(Label* context, const Optional<Shared<From>>& from) {
  if (from.query()) {
    return Optional<To>(context, from.get().template dynamic_pointer_cast<To>(context));
  } else {
    return Optional<To>();
  }
}

/**
 * Cast anything else.
 *
 * @return An optional, with a value only if @p from is of type To.
 */
template<class To, class From>
Optional<To> check_cast(const From& from) {
  return std::is_same<To,From>::value ? Optional<To>(from) : Optional<To>();
}

/**
 * Cast an optional of anything else.
 *
 * @return An optional, with a value only if @p from has a value of type To.
 */
template<class To, class From>
Optional<To> check_cast(const Optional<From>& from) {
  if (from.query()) {
    return check_cast<To>(from.get());
  } else {
    return Optional<To>();
  }
}

/**
 * Report unknown program option and abort.
 */
void unknown_option(const std::string& name);

}
