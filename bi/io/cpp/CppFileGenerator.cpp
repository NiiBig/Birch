/**
 * @file
 */
#include "bi/io/cpp/CppFileGenerator.hpp"

#include "bi/io/cpp/CppModelGenerator.hpp"
#include "bi/io/cpp/CppReturnGenerator.hpp"
#include "bi/program/all.hpp"
#include "bi/exception/all.hpp"

#include "boost/filesystem.hpp"
#include "boost/algorithm/string.hpp"

#include <sstream>
#include <iomanip>

bi::CppFileGenerator::CppFileGenerator(std::ostream& base, const int level,
    const bool header) :
    CppBaseGenerator(base, level, header) {
  //
}

void bi::CppFileGenerator::visit(const File* o) {
  line("/**");
  line(" * @file");
  line(" *");
  line(" * Automatically generated by Birch.");
  line(" */");

  if (header) {
    /* include guard */
    line("#pragma once\n");

    /* standard headers */
    line("#include \"bi/bi.hpp\"");
  } else {
    /* include header file */
    boost::filesystem::path file(o->path);
    file.replace_extension(".hpp");
    line("#include \"" << file.filename().string() << "\"\n");
  }

  /* imports */
  *this << o->imports;
  if (header && *o->imports) {
    line("");
  }

  /* main code */
  if (header) {
    line("namespace bi {");
  } else {
    //line("using namespace bi;\n");
  }
  *this << o->root;
  if (header) {
    line('}');
  }
}

void bi::CppFileGenerator::visit(const Import* o) {
  if (header) {
    line("#include \"" << hpp(o->path->file()) << "\"");
  }
}

void bi::CppFileGenerator::visit(const VarDeclaration* o) {
  if (header) {
    line("extern " << o->param->type << ' ' << o->param->name << ';');
  } else {
    start(o->param->type << " bi::" << o->param->name);
    if (*o->param->value) {
      middle(" = " << o->param->value);
    }
    finish(';');
  }
}

void bi::CppFileGenerator::visit(const ModelParameter* o) {
  if (*o->op == "=") {
    if (header) {
      ModelReference* base = dynamic_cast<ModelReference*>(o->base.get());
      assert(base);
      line("template<class Group = StackGroup>");
      line("using " << o->name << " = " << base->name << "<Group>;");
    }
  } else {
    CppModelGenerator auxModel(base, level, header);
    auxModel << o;
  }
}

void bi::CppFileGenerator::visit(const ProgParameter* o) {
  if (header) {
    line("void " << o->name << "_(int argc, char** argv);");
    line("extern \"C\" void " << o->name << "(int argc, char** argv);");
  } else {
    line("void bi::" << o->name << "_(int argc, char** argv) {");
    in();
    if (o->inputs.size() > 0) {
      /* option variables */
      for (auto iter = o->inputs.begin(); iter != o->inputs.end(); ++iter) {
        line(*iter << ';');
      }
      line("");

      /* option flags */
      line("enum {");
      in();
      for (auto iter = o->inputs.begin(); iter != o->inputs.end(); ++iter) {
        std::string flag = (*iter)->name->str() + "_ARG";
        boost::to_upper(flag);
        start(flag);
        if (iter == o->inputs.begin()) {
          middle(" = 256");
        }
        finish(',');
      }
      out();
      line("};");

      /* long options */
      line("int c, option_index;");
      line("option long_options[] = {");
      in();
      for (auto iter = o->inputs.begin(); iter != o->inputs.end(); ++iter) {
        const std::string& name = (*iter)->name->str();
        if (name.length() > 1) {
          std::string flag = name + "_ARG";
          boost::to_upper(flag);
          std::string option = name;
          boost::replace_all(option, "_", "-");

          line(
              "{\"" << option << "\", required_argument, 0, " << flag << " },");
        }
      }
      line("{0, 0, 0, 0}");
      out();
      line("};");

      /* short options */
      start("const char* short_options = \"");
      for (auto iter = o->inputs.begin(); iter != o->inputs.end(); ++iter) {
        const std::string& name = (*iter)->name->str();
        if (name.length() == 1) {
          middle(name << ':');
        }
      }
      finish("\";");

      /* read in options with getopt_long */
      line("opterr = 0; // handle error reporting ourselves");
      line(
          "c = getopt_long(argc, argv, short_options, long_options, &option_index);");
      line("while (c != -1) {");
      in();
      line("switch (c) {");
      in();

      for (auto iter = o->inputs.begin(); iter != o->inputs.end(); ++iter) {
        const std::string& name = (*iter)->name->str();
        std::string flag = name + "_ARG";
        boost::to_upper(flag);

        start("case ");
        if (name.length() > 1) {
          middle(flag);
        } else {
          middle('\'' << name << '\'');
        }
        finish(':');
        in();
        start(name << " = ");
        auto type = dynamic_cast<ModelReference*>((*iter)->type.get());
        assert(type);
        auto& typeName = type->name->str();
        if (typeName.compare("Boolean") == 0) {
          middle("atoi(optarg)");
        } else if (typeName.compare("Integer") == 0) {
          middle("atoi(optarg)");
        } else if (typeName.compare("Real") == 0) {
          middle("atof(optarg)");
        } else if (typeName.compare("String") == 0) {
          middle("optarg");
        } else {
          throw UnsupportedOptionTypeException(type);
        }
        finish(';');
        line("break;");
        out();
      }
      line("default:");
      in();
      line("throw UnknownOptionException(argv[optind - 1]);");
      line("break;");
      out();
      out();
      line('}');
      line(
          "c = getopt_long(argc, argv, short_options, long_options, &option_index);");
      out();
      line("}\n");
    }

    /* body of program */
    if (*o->braces) {
      CppBaseGenerator aux(base, level, header);
      aux << o->braces;
    }

    out();
    line("}\n");

    line("extern \"C\" void " << o->name << "(int argc, char** argv) {");
    in();
    line("bi::" << o->name << "_(argc, argv);");
    out();
    line("}\n");
  }
}

std::string bi::CppFileGenerator::hpp(const std::string& path) {
  boost::filesystem::path file = path;
  file.replace_extension(".hpp");
  return file.string();
}
